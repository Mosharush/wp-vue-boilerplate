name: Tests, Build & Deploy

on:
  push:
    branches-ignore:
      - 'dependabot/**'
    paths-ignore:
      - '**/*.md'

  workflow_dispatch:
    inputs:
      environment:
        description: 'Deploy to target environment:'
        type: choice
        required: true
        default: development
        options:
          - development
          - staging
          - production

      hash:
        description: 'Deploy with the commit hash:'
        type: string
        required: false

concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

env:
  RETAILERS_TEST_NUMITEMSTORUN: 100
  RETAILERS_TEST_RUN: true
  CI: true

jobs:
  setup:
    name: Setup Dependencies and Determine Affected Projects
    runs-on: ubuntu-latest
    outputs:
      affected_projects: ${{ steps.affected.outputs.affected_projects }}
      types: ${{ steps.affected.outputs.types }}
      projects_deploy: ${{ steps.affected.outputs.projects_deploy }}
      projects_s3: ${{ steps.affected.outputs.projects_s3 }}
      deploy_state: ${{ steps.vars.outputs.deploy_state }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Print ENV
        id: vars
        run: |
          echo "BRANCH_ENV=${BRANCH_ENV}"
          echo "EKS_CLUSTER_NAME=${EKS_CLUSTER_NAME}"
          echo "NODE_ENV=${NODE_ENV}"
          echo "VERSION_HASH=${VERSION_HASH}"
          echo "BASE_COMMIT=${BASE_COMMIT}"
          echo "CI_BRANCH=${CI_BRANCH}"
          echo "BRANCH=${BRANCH}"
          echo "NAMESPACE=${NAMESPACE}"
          echo "BRANCH_DOMAIN=${BRANCH_DOMAIN}"

          echo "deploy_state={\"VERSION_HASH\": \"${VERSION_HASH}\", \"NAMESPACE\": \"${NAMESPACE}\", \"BRANCH\": \"${BRANCH}\", \"BRANCH_DOMAIN\": \"${BRANCH_DOMAIN}\", \"BASE_COMMIT\": \"${BASE_COMMIT}\", \"BRANCH_ENV\": \"${BRANCH_ENV}\"}" >> $GITHUB_OUTPUT

      - name: Export AWS Secret manager
        id: aws-secret
        run: |
          # Get environment (base) secrets first
          ENV_SECRET_NAME=$(echo "${{ secrets.AWS_SECRET_MANAGER }}" | sed "s/dev/$BRANCH_ENV/")
          ENV_SECRETS=$(aws secretsmanager get-secret-value --secret-id $ENV_SECRET_NAME --query SecretString --output text)
          echo "Got base secrets from: $ENV_SECRET_NAME"

          # Try to get branch-specific secrets
          BRANCH_SECRET_NAME=$(echo "${{ secrets.AWS_SECRET_MANAGER }}" | sed "s/dev/${BRANCH}/")
          if aws secretsmanager describe-secret --secret-id "${BRANCH_SECRET_NAME}" 2>/dev/null; then
            echo "Found branch-specific secrets for: ${BRANCH}"
            BRANCH_SECRETS=$(aws secretsmanager get-secret-value --secret-id $BRANCH_SECRET_NAME --query SecretString --output text)
            
            # Merge secrets, with branch secrets taking precedence
            MERGED_SECRETS=$(echo "$ENV_SECRETS" "$BRANCH_SECRETS" | jq -s '.[0] * .[1]')
            echo "Merged environment and branch-specific secrets"
          else
            echo "No branch-specific secrets found for: ${BRANCH}, using environment secrets"
            MERGED_SECRETS=$ENV_SECRETS
          fi

          # Export the merged secrets
          for key in $(echo $MERGED_SECRETS | jq -r "to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]"); do
            export $key
            echo "Exported $key"
            echo "$key" >> $GITHUB_ENV
          done

      - name: Cache yarn cache
        uses: actions/cache@v4
        id: yarn-cache
        with:
          path: |
            .nx
            .yarn/cache
            **/node_modules
            .yarnrc.yml
            .angular
            libs/pkg/client.json
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Install dependencies
        run: yarn install --immutable
        if: steps.yarn-cache.outputs.cache-hit != 'true'

      - name: Post install
        run: |
          set -e yarn workspaces foreach -Apt run postinstall || {
            echo "Error: Post-install scripts failed" exit 1 
          }
        env:
          NODE_ENV: development

      - name: Find affected services
        id: affected
        run: |
          # Check if commit message includes [reset]
          commit_msg=$(git log -1 --pretty=%B --no-merges)
          echo "Commit message: $commit_msg"
          if [[ "$commit_msg" == *"[reset]"* ]]; then
              RESET_FLAG=true
          else
              RESET_FLAG=false
          fi

          if [[ "${BRANCH_ENV}" == 'prod' ]]; then
            echo "Production environment"
            if [[ "$RESET_FLAG" == "true" ]]; then
              echo "[reset] found in commit message, running full affected and deploy"
              affected_projects=$(yarn workspace @slk/monox show --hash)
            else
              if [[ "$BASE_COMMIT" == "$VERSION_HASH" ]]; then
                affected_projects=$(yarn workspace @slk/monox show --hash)
              else
                affected_projects=$(yarn workspace @slk/monox show --hash --since=${BASE_COMMIT} --affected)
              fi
            fi
          else
            if [[ "$RESET_FLAG" == "true" ]]; then
              echo "[reset] found in commit message, running full affected and deploy"
              affected_projects=$(yarn workspace @slk/monox show --hash)
            else
              affected_projects=$(yarn workspace @slk/monox show --hash --affected --since=${BASE_COMMIT:-main})
            fi
          fi

          projects_to_build=""
          projects_to_deploy=""
          projects_s3=""
          types_to_build=""

          ## loop with jq on affected_projects is array jsons
          while read project
          do
              name=$(echo "$project" | jq -r .name)
              location=$(echo "$project" | jq -r .location)
              hash=$(echo "$project" | jq -r .hash)
              deploy_type=$(echo "$project" | jq -r .deployment.type)
              deploy_target=$(echo "$project" | jq -r .deployment.target)
              deploy_needed=$(echo "$project" | jq -r .deployNeeded)
              has_build=$(echo "$project" | jq -r .buildNeeded)
              echo "Project name: $name"
              echo "Project hash: $hash"
              echo "Project path: $location"
              echo "Project hash build: $has_build"
              echo "Project deploy type: $deploy_type"

              if [ "$has_build" == "true" ]; then
                  projects_to_build+="$project,"

                  if [[ $deploy_target == "s3" ]]; then
                      projects_s3+="$project,"
                  fi
              fi

              if [ "$deploy_needed" == "true" ]; then
                  projects_to_deploy+="$project,"

                  # if not exists in types_to_build, add it
                  if [[ $types_to_build != *"$deploy_type"* ]]; then
                      types_to_build+="\"$deploy_type\","
                  fi
              fi
          done < <(echo $affected_projects | jq -c '.[]')

          projects_to_build=${projects_to_build%,}
          projects_json="[$projects_to_build]"
          echo "affected_projects=$projects_json" >> $GITHUB_OUTPUT
          echo $projects_json | jq

          projects_to_deploy=${projects_to_deploy%,}
          projects_deploy_json="[$projects_to_deploy]"
          echo "projects_deploy=$projects_deploy_json" >> $GITHUB_OUTPUT

          types_to_build=${types_to_build%,}
          types_json="[$types_to_build]"
          echo "types=$types_json" >> $GITHUB_OUTPUT

          projects_s3=${projects_s3%,}
          projects_s3_json="[$projects_s3]"
          echo "projects_s3=$projects_s3_json" >> $GITHUB_OUTPUT

          # Set affected_projects to an empty object if all are empty
          if [[ "$types_json" == "[]" && "$projects_deploy_json" == "[]" && "$projects_s3_json" == "[]" ]]; then
              echo "affected_projects=[]" >> $GITHUB_OUTPUT
          fi

  build_affected:
    name: Build
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ needs.setup.outputs.affected_projects != '[]' }}
    strategy:
      matrix:
        project: ${{ fromJson(needs.setup.outputs.affected_projects) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Restore yarn cache
        uses: actions/cache@v4
        id: yarn-cache
        with:
          path: |
            .nx
            .yarn/cache
            **/node_modules
            .yarnrc.yml
            .angular
            libs/pkg/client.json
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Export AWS Secret manager
        id: aws-secret
        run: |
          # Get environment (base) secrets first
          ENV_SECRET_NAME=$(echo "${{ secrets.AWS_SECRET_MANAGER }}" | sed "s/dev/$BRANCH_ENV/")
          ENV_SECRETS=$(aws secretsmanager get-secret-value --secret-id $ENV_SECRET_NAME --query SecretString --output text)
          echo "Got base secrets from: $ENV_SECRET_NAME"

          # Try to get branch-specific secrets
          BRANCH_SECRET_NAME=$(echo "${{ secrets.AWS_SECRET_MANAGER }}" | sed "s/dev/${BRANCH}/")
          if aws secretsmanager describe-secret --secret-id "${BRANCH_SECRET_NAME}" 2>/dev/null; then
            echo "Found branch-specific secrets for: ${BRANCH}"
            BRANCH_SECRETS=$(aws secretsmanager get-secret-value --secret-id $BRANCH_SECRET_NAME --query SecretString --output text)
            
            # Merge secrets, with branch secrets taking precedence
            MERGED_SECRETS=$(echo "$ENV_SECRETS" "$BRANCH_SECRETS" | jq -s '.[0] * .[1]')
            echo "Merged environment and branch-specific secrets"
          else
            echo "No branch-specific secrets found for: ${BRANCH}, using environment secrets"
            MERGED_SECRETS=$ENV_SECRETS
          fi

          # Export the merged secrets
          for key in $(echo $MERGED_SECRETS | jq -r "to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]"); do
            export $key
            echo "Exported $key"
            echo "$key" >> $GITHUB_ENV
          done

      - name: Build affected project
        run: |
          cd libs/pkg/ && yarn build # Generate client.json
          yarn workspace ${{ matrix.project.name }} build

      - name: Upload ${{ matrix.project.nameClean }} artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dists-${{ matrix.project.slug }}
          path: |
            !**/node_modules
            ./*/*/dist
          # keep ^it wildcard to keep dir structure on extract - can optimize to [services|wcs|sites...]
          if-no-files-found: warn
          overwrite: true

  test:
    name: Run Tests
    if: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/dev' }}
    runs-on: ubuntu-latest
    needs: setup
    timeout-minutes: 10
    continue-on-error: true
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Export AWS Secret manager
        id: aws-secret
        run: |
          # Get environment (base) secrets first
          ENV_SECRET_NAME=$(echo "${{ secrets.AWS_SECRET_MANAGER }}" | sed "s/dev/$BRANCH_ENV/")
          ENV_SECRETS=$(aws secretsmanager get-secret-value --secret-id $ENV_SECRET_NAME --query SecretString --output text)
          echo "Got base secrets from: $ENV_SECRET_NAME"

          # Try to get branch-specific secrets
          BRANCH_SECRET_NAME=$(echo "${{ secrets.AWS_SECRET_MANAGER }}" | sed "s/dev/${BRANCH}/")
          if aws secretsmanager describe-secret --secret-id "${BRANCH_SECRET_NAME}" 2>/dev/null; then
            echo "Found branch-specific secrets for: ${BRANCH}"
            BRANCH_SECRETS=$(aws secretsmanager get-secret-value --secret-id $BRANCH_SECRET_NAME --query SecretString --output text)
            
            # Merge secrets, with branch secrets taking precedence
            MERGED_SECRETS=$(echo "$ENV_SECRETS" "$BRANCH_SECRETS" | jq -s '.[0] * .[1]')
            echo "Merged environment and branch-specific secrets"
          else
            echo "No branch-specific secrets found for: ${BRANCH}, using environment secrets"
            MERGED_SECRETS=$ENV_SECRETS
          fi

          # Export the merged secrets
          for key in $(echo $MERGED_SECRETS | jq -r "to_entries|map(\"\(.key)=\(.value|tostring)\")|.[]"); do
            export $key
            echo "Exported $key"
            echo "$key" >> $GITHUB_ENV
          done

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Restore yarn cache
        uses: actions/cache/restore@v4
        id: yarn-cache
        with:
          path: |
            .nx
            .yarn/cache
            **/node_modules
            .yarnrc.yml
            .angular
            libs/pkg/client.json
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Print ENV
        run: |
          echo "BRANCH: ${BRANCH}"
          echo "NAMESPACE: ${NAMESPACE}"
          echo "BRANCH_ENV: ${BRANCH_ENV}"
          echo "BRANCH_DOMAIN: ${BRANCH_DOMAIN}"
          echo "EKS_CLUSTER_NAME: ${EKS_CLUSTER_NAME}"

      - name: Run tests
        run: |
          yarn test:all

  lint:
    name: Run Lint Checks
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Restore yarn cache
        uses: actions/cache/restore@v4
        id: yarn-cache
        with:
          path: |
            .nx
            .yarn/cache
            **/node_modules
            .yarnrc.yml
            .angular
            libs/pkg/client.json
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Run lint
        run: |
          yarn lint:all
          yarn tsc:all

  check-deps:
    name: Check Dependencies
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Restore yarn cache
        uses: actions/cache/restore@v4
        id: yarn-cache
        with:
          path: |
            .nx
            .yarn/cache
            **/node_modules
            .yarnrc.yml
            .angular
            libs/pkg/client.json
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Check dependencies
        run: yarn check-deps # --warn

  build_docker_images:
    name: Build Docker Images
    needs: [build_affected, setup]
    runs-on: ubuntu-latest
    if: ${{ needs.setup.outputs.types != '[]' }}
    strategy:
      matrix:
        type: ${{ fromJson(needs.setup.outputs.types) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: .
          pattern: dists-*
          merge-multiple: true

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: .
          pattern: dists-*
          merge-multiple: true

      - name: Build and push Docker image
        run: |
          context_dir=".devops/cloudapters/k8s/types/${{ matrix.type }}"
          commit_hash=${{ env.VERSION_HASH }}
          image_name=${{ secrets.AWS_ECR_REPOSITORY }}
          image_name=$(echo "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${image_name}")
          image_tag=$(echo "${{ matrix.type }}-${commit_hash}" | tr '[:upper:]' '[:lower:]')
          image_tag_latest=$(echo "${{ matrix.type }}-latest" | tr '[:upper:]' '[:lower:]')

          # Check if image with the specific tag already exists
          if aws ecr describe-images --repository-name ${{ secrets.AWS_ECR_REPOSITORY }} --image-ids imageTag=${image_tag} > /dev/null 2>&1; then
            echo "Image ${image_name}:${image_tag} already exists. Skipping build and push."
          else
            # TODO: Implement cache-from
            #docker pull ${image_name}:${image_tag_latest}
            #docker build --cache-from ${image_name}:${image_tag_latest} -t ${image_name}:${image_tag} -t ${image_name}:${image_tag_latest} --build-arg APP_NAME=${APP_NAME} --build-arg NODE_ENV=${NODE_ENV} --build-arg PORT=${PORT} -f ${context_dir}/Dockerfile ${{ github.workspace }}

            echo "Building and pushing Docker image..."
            docker build -t ${image_name}:${image_tag} -t ${image_name}:${image_tag_latest} --build-arg APP_NAME=${APP_NAME} --build-arg NODE_ENV=${NODE_ENV} --build-arg PORT=${PORT} -f ${context_dir}/Dockerfile ${{ github.workspace }}
            docker push ${image_name}:${image_tag}
            docker push ${image_name}:${image_tag_latest}
          fi

  gen_k8s_scripts:
    name: Prepare k8s
    runs-on: ubuntu-latest
    needs: [build_affected, setup]
    if: ${{ fromJson(needs.setup.outputs.projects_deploy) != '[]' }}
    strategy:
      matrix:
        project: ${{ fromJson(needs.setup.outputs.projects_deploy) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Restore yarn cache
        uses: actions/cache/restore@v4
        id: yarn-cache
        with:
          path: |
            .nx
            .yarn/cache
            **/node_modules
            .yarnrc.yml
            .angular
            libs/pkg/client.json
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Export current service ENVs
        run: |
          export PORT=${{ matrix.project.deployment.port }}
          export APP_NAME=${{ matrix.project.slug }}
          export BRANCH_ENV=${BRANCH_ENV}
          export EKS_CLUSTER_NAME=${EKS_CLUSTER_NAME}
          export NODE_ENV=${NODE_ENV}
          export VERSION_HASH=${VERSION_HASH}
          export BASE_COMMIT=${BASE_COMMIT}
          export CI_BRANCH=${CI_BRANCH}
          export BRANCH=${BRANCH}
          export BRANCH_DOMAIN=${BRANCH_DOMAIN}
          export NAMESPACE="${NAMESPACE}"

          echo "PORT=${PORT}" >> $GITHUB_ENV
          echo "APP_NAME=${APP_NAME}" >> $GITHUB_ENV
          echo "BRANCH_ENV=${BRANCH_ENV}" >> $GITHUB_ENV
          echo "EKS_CLUSTER_NAME=${EKS_CLUSTER_NAME}" >> $GITHUB_ENV
          echo "NODE_ENV=${NODE_ENV}" >> $GITHUB_ENV
          echo "VERSION_HASH=${VERSION_HASH}" >> $GITHUB_ENV
          echo "BASE_COMMIT=${BASE_COMMIT}" >> $GITHUB_ENV
          echo "CI_BRANCH=${CI_BRANCH}" >> $GITHUB_ENV
          echo "BRANCH=${BRANCH}" >> $GITHUB_ENV
          echo "BRANCH_DOMAIN=${BRANCH_DOMAIN}" >> $GITHUB_ENV
          echo "NAMESPACE=${NAMESPACE}" >> $GITHUB_ENV

      - name: Print ENV
        run: |
          echo "PORT=${PORT}"
          echo APP_NAME=${APP_NAME}
          echo "BRANCH_ENV=${BRANCH_ENV}"
          echo "EKS_CLUSTER_NAME=${EKS_CLUSTER_NAME}"
          echo "NODE_ENV=${NODE_ENV}"
          echo "VERSION_HASH=${VERSION_HASH}"
          echo "BASE_COMMIT=${BASE_COMMIT}"
          echo "CI_BRANCH=${CI_BRANCH}"
          echo "BRANCH=${BRANCH}"
          echo "BRANCH_DOMAIN=${BRANCH_DOMAIN}"
          echo "NAMESPACE=${NAMESPACE}"

      - name: Run k8s script for project
        run: |
          yarn workspace @slk/k8s run deploy --pkg-path=${{ matrix.project.location }} --dry-run
        env:
          image_name: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ secrets.AWS_ECR_REPOSITORY }}

      - name: Upload ${{ matrix.project.nameClean }} dist yaml files
        uses: actions/upload-artifact@v4
        with:
          name: k8s_yml-${{ matrix.project.slug }}
          path: .devops/cloudapters/k8s/types/*/dist/yml
          overwrite: true

  deploy_approved:
    name: Deploy approval check
    runs-on: ubuntu-latest
    permissions:
      actions: write
    needs: [build_affected]
    outputs:
      deploy_approved: ${{ steps.check_approval.outputs.deploy_approved }}
    steps:
      - name: Display rerun information
        run: |
          echo "Run attempt: ${{ github.run_attempt }}"
          echo "Run number: ${{ github.run_number }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Event name: ${{ github.event_name }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Actor: ${{ github.actor }}"
          echo "Ref: ${{ github.ref }}"
      - name: ðŸš¨Check if is manual approval
        id: check_approval
        run: |
          if [ "${{ github.run_attempt }}" == 1 && github.ref == 'refs/heads/main' ]; then
            echo "::warning::Deployment is not allowed on first run attempt, to continue deployment Re-run this job by clicking 'Re-run jobs > Re-run *failed* jobs'"
            echo "deploy_approved=false" >> $GITHUB_OUTPUT
            # cancel current workflow
            curl -X POST -H "Accept: application/vnd.github.v3+json" -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/cancel
            sleep 60
          else
            echo "Deployment is allowed. Continue with deployment."
            echo "deploy_approved=true" >> $GITHUB_OUTPUT
          fi

  deploy_production:
    name: Production deploy to k8s
    runs-on: ubuntu-latest
    needs: [deploy_approved, gen_k8s_scripts, build_docker_images]
    if: ${{ github.ref == 'refs/heads/main' && needs.deploy_approved.outputs.deploy_approved == 'true' }}
    environment:
      name: ${{ github.ref_name }}
      url: ${{ format('https://office.{0}', env.BRANCH_DOMAIN) }}
    steps:
      - name: Display rerun information
        run: |
          echo "Run attempt: ${{ github.run_attempt }}"
          echo "Run number: ${{ github.run_number }}"
          echo "Run ID: ${{ github.run_id }}"
          echo "Event name: ${{ github.event_name }}"
          echo "Workflow: ${{ github.workflow }}"
          echo "Actor: ${{ github.actor }}"
          echo "Ref: ${{ github.ref }}"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Download all app types yaml files
        uses: actions/download-artifact@v4
        with:
          pattern: k8s_yml-*
          path: .devops/cloudapters/k8s/types
          merge-multiple: true

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Deploy to Kubernetes
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${EKS_CLUSTER_NAME}
          kubectl config set-context --current --namespace="${NAMESPACE}"
          combined_file=$(mktemp)
          find .devops/cloudapters/k8s/types/*/dist/yml -type f \( -name '*.yml' -o -name '*.yaml' \) -print0 | sort -z | xargs -0 -I{} sh -c 'cat {}; echo "\n---\n"' > "$combined_file"
          cat "$combined_file"
          kubectl apply -f "$combined_file"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}

  deploy_feature_branches:
    name: Feature Branch deploy to k8s
    runs-on: ubuntu-latest
    needs: [deploy_approved, gen_k8s_scripts, build_docker_images]
    if: ${{ github.ref != 'refs/heads/main' && needs.deploy_approved.outputs.deploy_approved == 'true' }}
    environment:
      name: ${{ github.ref_name }}
      url: ${{ format('https://office-{0}.selectika.ai', env.BRANCH) }}
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Download all app types yaml files
        uses: actions/download-artifact@v4
        with:
          pattern: k8s_yml-*
          path: .devops/cloudapters/k8s/types
          merge-multiple: true

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Deploy to Kubernetes
        run: |
          aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${EKS_CLUSTER_NAME}
          kubectl config set-context --current --namespace="${NAMESPACE}"
          combined_file=$(mktemp)
          find .devops/cloudapters/k8s/types/*/dist/yml -type f \( -name '*.yml' -o -name '*.yaml' \) -print0 | sort -z | xargs -0 -I{} sh -c 'cat {}; echo "\n---\n"' > "$combined_file"
          cat "$combined_file"
          kubectl apply -f "$combined_file"
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}

  deploy_s3:
    name: Deploy to S3
    runs-on: ubuntu-latest
    needs: [deploy_approved, setup]
    if: ${{ fromJson(needs.setup.outputs.projects_s3) != '[]' && needs.deploy_approved.outputs.deploy_approved == 'true' }}
    strategy:
      matrix:
        project: ${{ fromJson(needs.setup.outputs.projects_s3) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: .
          pattern: dists-*
          merge-multiple: true

      - name: Export Variables
        uses: './.github/actions/export-vars'
        with:
          ROOT_DOMAIN: ${{ vars.ROOT_DOMAIN }}
          EKS_CLUSTER_NAME: ${{ vars.EKS_CLUSTER_NAME }}
          EKS_DEV_CLUSTER_NAME: ${{ vars.EKS_DEV_CLUSTER_NAME }}
          EKS_STAGE_CLUSTER_NAME: ${{ vars.EKS_STAGE_CLUSTER_NAME }}
          EKS_PROD_CLUSTER_NAME: ${{ vars.EKS_PROD_CLUSTER_NAME }}
          ENVIRONMENT: ${{ github.event.inputs.environment || '' }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Upload to S3
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          project_dir="$PWD/${{ matrix.project.location }}"
          source_dir=${{ matrix.project.deployment.source }}
          echo "Source dir: $source_dir"
          dist_dir="$project_dir/dist"
          if [[ -n "$source_dir" ]]; then
              if [[ "$source_dir" == "." ]]; then
                  dist_dir="$project_dir"
              else
                  dist_dir="$project_dir/$source_dir"
              fi
          fi

          env_path="${BRANCH}"
          if [[ "${BRANCH_ENV:0:4}" == "prod" ]]; then
              env_path="prod"
          fi

          s3_bucket_url="s3://${{ matrix.project.deployment.bucket }}.${ROOT_DOMAIN}/${env_path}/${{ matrix.project.slug }}"
          if [[ "${{ matrix.project.deployment.type }}" == "website" ]]; then
            s3_bucket_url="s3://${{ matrix.project.deployment.bucket }}.${ROOT_DOMAIN}" # prod on root path
            if [[ "${BRANCH_ENV}" != "prod" ]]; then
              s3_bucket_url="s3://web.${ROOT_DOMAIN}/${BRANCH}/${{ matrix.project.slug }}"  # dev on sub paths in sites bucket by branch dir
            fi
          fi

          echo "Current S3 bucket URL: $s3_bucket_url"
          echo "Current project location: $project_dir"
          echo "Current dist dir: $dist_dir"

          aws s3 cp "$dist_dir" "$s3_bucket_url" --recursive
